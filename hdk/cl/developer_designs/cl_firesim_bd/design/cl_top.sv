// Xilinx template design file for Amazon FPGA Hardware Development Kit
//
// File: cl_top.sv
// Starting-point top-level HDL Custom Logic (CL) design file
// If all custom logic is contained within the cl.bd block diagram,
//   then no further changes are required to this cl_top file.

module cl_top (
  // Do not modify the interface of this module.
  // User-defined custom logic cannot create additional external ports.
  `include "cl_ports_hlx.vh"
  );

  // Copies from the HDL wrapper generated by vivado for a BD
  // OCL drives the the simulation AXI4-lite bus
  // I manually reduced the OCL address widths to match what was done
  // previously. I can't get the BD generation flow to reduce the width of the
  // IF either
  wire [24:0]M_AXI4_OCL_araddr;
  wire [2:0]M_AXI4_OCL_arprot;
  wire M_AXI4_OCL_arready;
  wire M_AXI4_OCL_arvalid;
  wire [24:0]M_AXI4_OCL_awaddr;
  wire [2:0]M_AXI4_OCL_awprot;
  wire M_AXI4_OCL_awready;
  wire M_AXI4_OCL_awvalid;
  wire M_AXI4_OCL_bready;
  wire [1:0]M_AXI4_OCL_bresp;
  wire M_AXI4_OCL_bvalid;
  wire [31:0]M_AXI4_OCL_rdata;
  wire M_AXI4_OCL_rready;
  wire [1:0]M_AXI4_OCL_rresp;
  wire M_AXI4_OCL_rvalid;
  wire [31:0]M_AXI4_OCL_wdata;
  wire M_AXI4_OCL_wready;
  wire [3:0]M_AXI4_OCL_wstrb;
  wire M_AXI4_OCL_wvalid;

  // PCIS
  wire [63:0]M_AXI4_PCIS_araddr;
  wire [1:0]M_AXI4_PCIS_arburst;
  wire [3:0]M_AXI4_PCIS_arcache;
  wire [5:0]M_AXI4_PCIS_arid;
  wire [7:0]M_AXI4_PCIS_arlen;
  wire [0:0]M_AXI4_PCIS_arlock;
  wire [2:0]M_AXI4_PCIS_arprot;
  wire [3:0]M_AXI4_PCIS_arqos;
  wire M_AXI4_PCIS_arready;
  wire [3:0]M_AXI4_PCIS_arregion;
  wire [2:0]M_AXI4_PCIS_arsize;
  wire M_AXI4_PCIS_arvalid;
  wire [63:0]M_AXI4_PCIS_awaddr;
  wire [1:0]M_AXI4_PCIS_awburst;
  wire [3:0]M_AXI4_PCIS_awcache;
  wire [5:0]M_AXI4_PCIS_awid;
  wire [7:0]M_AXI4_PCIS_awlen;
  wire [0:0]M_AXI4_PCIS_awlock;
  wire [2:0]M_AXI4_PCIS_awprot;
  wire [3:0]M_AXI4_PCIS_awqos;
  wire M_AXI4_PCIS_awready;
  wire [3:0]M_AXI4_PCIS_awregion;
  wire [2:0]M_AXI4_PCIS_awsize;
  wire M_AXI4_PCIS_awvalid;
  wire [5:0]M_AXI4_PCIS_bid;
  wire M_AXI4_PCIS_bready;
  wire [1:0]M_AXI4_PCIS_bresp;
  wire M_AXI4_PCIS_bvalid;
  wire [511:0]M_AXI4_PCIS_rdata;
  wire [5:0]M_AXI4_PCIS_rid;
  wire M_AXI4_PCIS_rlast;
  wire M_AXI4_PCIS_rready;
  wire [1:0]M_AXI4_PCIS_rresp;
  wire M_AXI4_PCIS_rvalid;
  wire [511:0]M_AXI4_PCIS_wdata;
  wire M_AXI4_PCIS_wlast;
  wire M_AXI4_PCIS_wready;
  wire [63:0]M_AXI4_PCIS_wstrb;
  wire M_AXI4_PCIS_wvalid;
  // Channel C DDR
  wire [33:0]S_AXI4_DDR_C_araddr;
  wire [1:0]S_AXI4_DDR_C_arburst;
  wire [3:0]S_AXI4_DDR_C_arcache;
  wire [4:0]S_AXI4_DDR_C_arid;
  wire [7:0]S_AXI4_DDR_C_arlen;
  wire [0:0]S_AXI4_DDR_C_arlock;
  wire [2:0]S_AXI4_DDR_C_arprot;
  wire [3:0]S_AXI4_DDR_C_arqos;
  wire S_AXI4_DDR_C_arready;
  wire [3:0]S_AXI4_DDR_C_arregion;
  wire [2:0]S_AXI4_DDR_C_arsize;
  wire S_AXI4_DDR_C_arvalid;
  wire [33:0]S_AXI4_DDR_C_awaddr;
  wire [1:0]S_AXI4_DDR_C_awburst;
  wire [3:0]S_AXI4_DDR_C_awcache;
  wire [4:0]S_AXI4_DDR_C_awid;
  wire [7:0]S_AXI4_DDR_C_awlen;
  wire [0:0]S_AXI4_DDR_C_awlock;
  wire [2:0]S_AXI4_DDR_C_awprot;
  wire [3:0]S_AXI4_DDR_C_awqos;
  wire S_AXI4_DDR_C_awready;
  wire [3:0]S_AXI4_DDR_C_awregion;
  wire [2:0]S_AXI4_DDR_C_awsize;
  wire S_AXI4_DDR_C_awvalid;
  wire [4:0]S_AXI4_DDR_C_bid;
  wire S_AXI4_DDR_C_bready;
  wire [1:0]S_AXI4_DDR_C_bresp;
  wire S_AXI4_DDR_C_bvalid;
  wire [63:0]S_AXI4_DDR_C_rdata;
  wire [4:0]S_AXI4_DDR_C_rid;
  wire S_AXI4_DDR_C_rlast;
  wire S_AXI4_DDR_C_rready;
  wire [1:0]S_AXI4_DDR_C_rresp;
  wire S_AXI4_DDR_C_rvalid;
  wire [63:0]S_AXI4_DDR_C_wdata;
  wire S_AXI4_DDR_C_wlast;
  wire S_AXI4_DDR_C_wready;
  wire [7:0]S_AXI4_DDR_C_wstrb;
  wire S_AXI4_DDR_C_wvalid;

  // Clocks generated by a PLL in the block diagram
  wire firesim_clk1;
  wire firesim_clk2;
  wire firesim_clk3;
  wire firesim_clk4;
  wire firesim_clk5;
  wire firesim_clk6;
  // Asynchronous reset in shell clock domain
  wire rst_main_shell_n;

  // The user must select a clock manually as was done in the old flow
  // and synchronize a reset to it
  wire firesim_selected_clock;
  logic firesim_sync_nreset;

  assign firesim_selected_clock = firesim_clk3;

  logic pre_sync_rst_n_firesim;
  always_ff @(negedge rst_main_shell_n or posedge firesim_selected_clock)
     if (!rst_main_shell_n)
     begin
        pre_sync_rst_n_firesim  <= 0;
        firesim_sync_nreset <= 0;
     end
     else
     begin
        pre_sync_rst_n_firesim  <= 1;
        firesim_sync_nreset <= pre_sync_rst_n_firesim;
     end

  // Instantiate the Xilinx Vivado IP Integrator Block Diagram.
  cl cl_inst (
    // Users optionally add new BD external port connections here.
    // Terminate user-defined port connections list with a trailing comma.
    .M_AXI4_OCL_araddr(M_AXI4_OCL_araddr),
    .M_AXI4_OCL_arprot(M_AXI4_OCL_arprot),
    .M_AXI4_OCL_arready(M_AXI4_OCL_arready),
    .M_AXI4_OCL_arvalid(M_AXI4_OCL_arvalid),
    .M_AXI4_OCL_awaddr(M_AXI4_OCL_awaddr),
    .M_AXI4_OCL_awprot(M_AXI4_OCL_awprot),
    .M_AXI4_OCL_awready(M_AXI4_OCL_awready),
    .M_AXI4_OCL_awvalid(M_AXI4_OCL_awvalid),
    .M_AXI4_OCL_bready(M_AXI4_OCL_bready),
    .M_AXI4_OCL_bresp(M_AXI4_OCL_bresp),
    .M_AXI4_OCL_bvalid(M_AXI4_OCL_bvalid),
    .M_AXI4_OCL_rdata(M_AXI4_OCL_rdata),
    .M_AXI4_OCL_rready(M_AXI4_OCL_rready),
    .M_AXI4_OCL_rresp(M_AXI4_OCL_rresp),
    .M_AXI4_OCL_rvalid(M_AXI4_OCL_rvalid),
    .M_AXI4_OCL_wdata(M_AXI4_OCL_wdata),
    .M_AXI4_OCL_wready(M_AXI4_OCL_wready),
    .M_AXI4_OCL_wstrb(M_AXI4_OCL_wstrb),
    .M_AXI4_OCL_wvalid(M_AXI4_OCL_wvalid),
    .M_AXI4_PCIS_araddr(M_AXI4_PCIS_araddr),
    .M_AXI4_PCIS_arburst(M_AXI4_PCIS_arburst),
    .M_AXI4_PCIS_arcache(M_AXI4_PCIS_arcache),
    .M_AXI4_PCIS_arid(M_AXI4_PCIS_arid),
    .M_AXI4_PCIS_arlen(M_AXI4_PCIS_arlen),
    .M_AXI4_PCIS_arlock(M_AXI4_PCIS_arlock),
    .M_AXI4_PCIS_arprot(M_AXI4_PCIS_arprot),
    .M_AXI4_PCIS_arqos(M_AXI4_PCIS_arqos),
    .M_AXI4_PCIS_arready(M_AXI4_PCIS_arready),
    .M_AXI4_PCIS_arregion(M_AXI4_PCIS_arregion),
    .M_AXI4_PCIS_arsize(M_AXI4_PCIS_arsize),
    .M_AXI4_PCIS_arvalid(M_AXI4_PCIS_arvalid),
    .M_AXI4_PCIS_awaddr(M_AXI4_PCIS_awaddr),
    .M_AXI4_PCIS_awburst(M_AXI4_PCIS_awburst),
    .M_AXI4_PCIS_awcache(M_AXI4_PCIS_awcache),
    .M_AXI4_PCIS_awid(M_AXI4_PCIS_awid),
    .M_AXI4_PCIS_awlen(M_AXI4_PCIS_awlen),
    .M_AXI4_PCIS_awlock(M_AXI4_PCIS_awlock),
    .M_AXI4_PCIS_awprot(M_AXI4_PCIS_awprot),
    .M_AXI4_PCIS_awqos(M_AXI4_PCIS_awqos),
    .M_AXI4_PCIS_awready(M_AXI4_PCIS_awready),
    .M_AXI4_PCIS_awregion(M_AXI4_PCIS_awregion),
    .M_AXI4_PCIS_awsize(M_AXI4_PCIS_awsize),
    .M_AXI4_PCIS_awvalid(M_AXI4_PCIS_awvalid),
    .M_AXI4_PCIS_bid(M_AXI4_PCIS_bid),
    .M_AXI4_PCIS_bready(M_AXI4_PCIS_bready),
    .M_AXI4_PCIS_bresp(M_AXI4_PCIS_bresp),
    .M_AXI4_PCIS_bvalid(M_AXI4_PCIS_bvalid),
    .M_AXI4_PCIS_rdata(M_AXI4_PCIS_rdata),
    .M_AXI4_PCIS_rid(M_AXI4_PCIS_rid),
    .M_AXI4_PCIS_rlast(M_AXI4_PCIS_rlast),
    .M_AXI4_PCIS_rready(M_AXI4_PCIS_rready),
    .M_AXI4_PCIS_rresp(M_AXI4_PCIS_rresp),
    .M_AXI4_PCIS_rvalid(M_AXI4_PCIS_rvalid),
    .M_AXI4_PCIS_wdata(M_AXI4_PCIS_wdata),
    .M_AXI4_PCIS_wlast(M_AXI4_PCIS_wlast),
    .M_AXI4_PCIS_wready(M_AXI4_PCIS_wready),
    .M_AXI4_PCIS_wstrb(M_AXI4_PCIS_wstrb),
    .M_AXI4_PCIS_wvalid(M_AXI4_PCIS_wvalid),
    .S_AXI4_DDR_C_araddr(S_AXI4_DDR_C_araddr),
    .S_AXI4_DDR_C_arburst(S_AXI4_DDR_C_arburst),
    .S_AXI4_DDR_C_arcache(S_AXI4_DDR_C_arcache),
    .S_AXI4_DDR_C_arid(S_AXI4_DDR_C_arid),
    .S_AXI4_DDR_C_arlen(S_AXI4_DDR_C_arlen),
    .S_AXI4_DDR_C_arlock(S_AXI4_DDR_C_arlock),
    .S_AXI4_DDR_C_arprot(S_AXI4_DDR_C_arprot),
    .S_AXI4_DDR_C_arqos(S_AXI4_DDR_C_arqos),
    .S_AXI4_DDR_C_arready(S_AXI4_DDR_C_arready),
    .S_AXI4_DDR_C_arregion(S_AXI4_DDR_C_arregion),
    .S_AXI4_DDR_C_arsize(S_AXI4_DDR_C_arsize),
    .S_AXI4_DDR_C_arvalid(S_AXI4_DDR_C_arvalid),
    .S_AXI4_DDR_C_awaddr(S_AXI4_DDR_C_awaddr),
    .S_AXI4_DDR_C_awburst(S_AXI4_DDR_C_awburst),
    .S_AXI4_DDR_C_awcache(S_AXI4_DDR_C_awcache),
    .S_AXI4_DDR_C_awid(S_AXI4_DDR_C_awid),
    .S_AXI4_DDR_C_awlen(S_AXI4_DDR_C_awlen),
    .S_AXI4_DDR_C_awlock(S_AXI4_DDR_C_awlock),
    .S_AXI4_DDR_C_awprot(S_AXI4_DDR_C_awprot),
    .S_AXI4_DDR_C_awqos(S_AXI4_DDR_C_awqos),
    .S_AXI4_DDR_C_awready(S_AXI4_DDR_C_awready),
    .S_AXI4_DDR_C_awregion(S_AXI4_DDR_C_awregion),
    .S_AXI4_DDR_C_awsize(S_AXI4_DDR_C_awsize),
    .S_AXI4_DDR_C_awvalid(S_AXI4_DDR_C_awvalid),
    .S_AXI4_DDR_C_bid(S_AXI4_DDR_C_bid),
    .S_AXI4_DDR_C_bready(S_AXI4_DDR_C_bready),
    .S_AXI4_DDR_C_bresp(S_AXI4_DDR_C_bresp),
    .S_AXI4_DDR_C_bvalid(S_AXI4_DDR_C_bvalid),
    .S_AXI4_DDR_C_rdata(S_AXI4_DDR_C_rdata),
    .S_AXI4_DDR_C_rid(S_AXI4_DDR_C_rid),
    .S_AXI4_DDR_C_rlast(S_AXI4_DDR_C_rlast),
    .S_AXI4_DDR_C_rready(S_AXI4_DDR_C_rready),
    .S_AXI4_DDR_C_rresp(S_AXI4_DDR_C_rresp),
    .S_AXI4_DDR_C_rvalid(S_AXI4_DDR_C_rvalid),
    .S_AXI4_DDR_C_wdata(S_AXI4_DDR_C_wdata),
    .S_AXI4_DDR_C_wlast(S_AXI4_DDR_C_wlast),
    .S_AXI4_DDR_C_wready(S_AXI4_DDR_C_wready),
    .S_AXI4_DDR_C_wstrb(S_AXI4_DDR_C_wstrb),
    .S_AXI4_DDR_C_wvalid(S_AXI4_DDR_C_wvalid),
    .firesim_clk1(firesim_clk1),
    .firesim_clk2(firesim_clk2),
    .firesim_clk3(firesim_clk3),
    .firesim_clk4(firesim_clk4),
    .firesim_clk5(firesim_clk5),
    .firesim_clk6(firesim_clk6),
    .firesim_selected_clock(firesim_selected_clock),
    .firesim_sync_nreset(firesim_sync_nreset),
    .rst_main_n(rst_main_shell_n),
    // Do not remove the following mandatory port connections.
    `include "sh_connectors.vh"
    );

  F1Shim firesim_top (
   .clock(firesim_selected_clock),
   .reset(!firesim_sync_nreset),
   .io_master_aw_ready(M_AXI4_OCL_awready),
   .io_master_aw_valid(M_AXI4_OCL_awvalid),
   .io_master_aw_bits_addr(M_AXI4_OCL_awaddr[24:0]),
   .io_master_aw_bits_len(8'h0),
   .io_master_aw_bits_size(3'h2),
   .io_master_aw_bits_burst(2'h1),
   .io_master_aw_bits_lock(1'h0),
   .io_master_aw_bits_cache(4'h0),
   .io_master_aw_bits_prot(3'h0), //unused? (could connect?)
   .io_master_aw_bits_qos(4'h0),
   .io_master_aw_bits_region(4'h0),
   .io_master_aw_bits_id(12'h0),
   .io_master_aw_bits_user(1'h0),
   .io_master_w_ready(M_AXI4_OCL_wready),
   .io_master_w_valid(M_AXI4_OCL_wvalid),
   .io_master_w_bits_data(M_AXI4_OCL_wdata),
   .io_master_w_bits_last(1'h1),
   .io_master_w_bits_id(12'h0),
   .io_master_w_bits_strb(M_AXI4_OCL_wstrb), //OR 8'hff
   .io_master_w_bits_user(1'h0),
   .io_master_b_ready(M_AXI4_OCL_bready),
   .io_master_b_valid(M_AXI4_OCL_bvalid),
   .io_master_b_bits_resp(M_AXI4_OCL_bresp),
   .io_master_b_bits_id(),      // UNUSED at top level
   .io_master_b_bits_user(),    // UNUSED at top level
   .io_master_ar_ready(M_AXI4_OCL_arready),
   .io_master_ar_valid(M_AXI4_OCL_arvalid),
   .io_master_ar_bits_addr(M_AXI4_OCL_araddr[24:0]),
   .io_master_ar_bits_len(8'h0),
   .io_master_ar_bits_size(3'h2),
   .io_master_ar_bits_burst(2'h1),
   .io_master_ar_bits_lock(1'h0),
   .io_master_ar_bits_cache(4'h0),
   .io_master_ar_bits_prot(3'h0),
   .io_master_ar_bits_qos(4'h0),
   .io_master_ar_bits_region(4'h0),
   .io_master_ar_bits_id(12'h0),
   .io_master_ar_bits_user(1'h0),
   .io_master_r_ready(M_AXI4_OCL_rready),
   .io_master_r_valid(M_AXI4_OCL_rvalid),
   .io_master_r_bits_resp(M_AXI4_OCL_rresp),
   .io_master_r_bits_data(M_AXI4_OCL_rdata),
   .io_master_r_bits_last(), //UNUSED at top level
   .io_master_r_bits_id(),      // UNUSED at top level
   .io_master_r_bits_user(),    // UNUSED at top level

    // special NIC master interface
   .io_dma_aw_ready(M_AXI4_PCIS_awready),
   .io_dma_aw_valid(M_AXI4_PCIS_awvalid),
   .io_dma_aw_bits_addr(M_AXI4_PCIS_awaddr),
   .io_dma_aw_bits_len(M_AXI4_PCIS_awlen),
   .io_dma_aw_bits_size(M_AXI4_PCIS_awsize),
   .io_dma_aw_bits_burst(2'h1),
   .io_dma_aw_bits_lock(1'h0),
   .io_dma_aw_bits_cache(4'h0),
   .io_dma_aw_bits_prot(3'h0), //unused? (could connect?)
   .io_dma_aw_bits_qos(4'h0),
   .io_dma_aw_bits_region(4'h0),
   .io_dma_aw_bits_id(M_AXI4_PCIS_awid),
   .io_dma_aw_bits_user(1'h0),
   .io_dma_w_ready(M_AXI4_PCIS_wready),
   .io_dma_w_valid(M_AXI4_PCIS_wvalid),
   .io_dma_w_bits_data(M_AXI4_PCIS_wdata),
   .io_dma_w_bits_last(M_AXI4_PCIS_wlast),
   .io_dma_w_bits_id(6'h0),
   .io_dma_w_bits_strb(M_AXI4_PCIS_wstrb),
   .io_dma_w_bits_user(1'h0),
   .io_dma_b_ready(M_AXI4_PCIS_bready),
   .io_dma_b_valid(M_AXI4_PCIS_bvalid),
   .io_dma_b_bits_resp(M_AXI4_PCIS_bresp),
   .io_dma_b_bits_id(M_AXI4_PCIS_bid),
   .io_dma_b_bits_user(),    // UNUSED at top level
   .io_dma_ar_ready(M_AXI4_PCIS_arready),
   .io_dma_ar_valid(M_AXI4_PCIS_arvalid),
   .io_dma_ar_bits_addr(M_AXI4_PCIS_araddr),
   .io_dma_ar_bits_len(M_AXI4_PCIS_arlen),
   .io_dma_ar_bits_size(M_AXI4_PCIS_arsize),
   .io_dma_ar_bits_burst(2'h1),
   .io_dma_ar_bits_lock(1'h0),
   .io_dma_ar_bits_cache(4'h0),
   .io_dma_ar_bits_prot(3'h0),
   .io_dma_ar_bits_qos(4'h0),
   .io_dma_ar_bits_region(4'h0),
   .io_dma_ar_bits_id(M_AXI4_PCIS_arid),
   .io_dma_ar_bits_user(1'h0),
   .io_dma_r_ready(M_AXI4_PCIS_rready),
   .io_dma_r_valid(M_AXI4_PCIS_rvalid),
   .io_dma_r_bits_resp(M_AXI4_PCIS_rresp),
   .io_dma_r_bits_data(M_AXI4_PCIS_rdata),
   .io_dma_r_bits_last(M_AXI4_PCIS_rlast),
   .io_dma_r_bits_id(M_AXI4_PCIS_rid),

   .io_slave_aw_ready(S_AXI4_DDR_C_awready),
   .io_slave_aw_valid(S_AXI4_DDR_C_awvalid),
   .io_slave_aw_bits_addr(S_AXI4_DDR_C_awaddr),
   .io_slave_aw_bits_len(S_AXI4_DDR_C_awlen),
   .io_slave_aw_bits_size(S_AXI4_DDR_C_awsize),
   .io_slave_aw_bits_burst(S_AXI4_DDR_C_awburst), // not available on DDR IF
   .io_slave_aw_bits_lock(S_AXI4_DDR_C_awlock), // not available on DDR IF
   .io_slave_aw_bits_cache(S_AXI4_DDR_C_awcache), // not available on DDR IF
   .io_slave_aw_bits_prot(S_AXI4_DDR_C_awprot), // not available on DDR IF
   .io_slave_aw_bits_qos(S_AXI4_DDR_C_awqos), // not available on DDR IF
   .io_slave_aw_bits_region(S_AXI4_DDR_C_awregion), // not available on DDR IF
   .io_slave_aw_bits_id(S_AXI4_DDR_C_awid),

   .io_slave_w_ready(S_AXI4_DDR_C_wready),
   .io_slave_w_valid(S_AXI4_DDR_C_wvalid),
   .io_slave_w_bits_data(S_AXI4_DDR_C_wdata),
   .io_slave_w_bits_last(S_AXI4_DDR_C_wlast),
   .io_slave_w_bits_strb(S_AXI4_DDR_C_wstrb),

   .io_slave_b_ready(S_AXI4_DDR_C_bready),
   .io_slave_b_valid(S_AXI4_DDR_C_bvalid),
   .io_slave_b_bits_resp(S_AXI4_DDR_C_bresp),
   .io_slave_b_bits_id(S_AXI4_DDR_C_bid),

   .io_slave_ar_ready(S_AXI4_DDR_C_arready),
   .io_slave_ar_valid(S_AXI4_DDR_C_arvalid),
   .io_slave_ar_bits_addr(S_AXI4_DDR_C_araddr),
   .io_slave_ar_bits_len(S_AXI4_DDR_C_arlen),
   .io_slave_ar_bits_size(S_AXI4_DDR_C_arsize),
   .io_slave_ar_bits_burst(S_AXI4_DDR_C_arburst), // not available on DDR IF
   .io_slave_ar_bits_lock(S_AXI4_DDR_C_arlock), // not available on DDR IF
   .io_slave_ar_bits_cache(S_AXI4_DDR_C_arcache), // not available on DDR IF
   .io_slave_ar_bits_prot(S_AXI4_DDR_C_arprot), // not available on DDR IF
   .io_slave_ar_bits_qos(S_AXI4_DDR_C_arqos), // not available on DDR IF
   .io_slave_ar_bits_region(S_AXI4_DDR_C_arregion), // not available on DDR IF
   .io_slave_ar_bits_id(S_AXI4_DDR_C_arid), // not available on DDR IF

   .io_slave_r_ready(S_AXI4_DDR_C_rready),
   .io_slave_r_valid(S_AXI4_DDR_C_rvalid),
   .io_slave_r_bits_resp(S_AXI4_DDR_C_rresp),
   .io_slave_r_bits_data(S_AXI4_DDR_C_rdata),
   .io_slave_r_bits_last(S_AXI4_DDR_C_rlast),
   .io_slave_r_bits_id(S_AXI4_DDR_C_rid)
);
endmodule
